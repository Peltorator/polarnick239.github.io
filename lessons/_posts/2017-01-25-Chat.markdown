---
layout: 239post
title:  "Задание 40. Простой echo-сервер"
date:   2017-01-25 12:00:00 +0300
categories: 239 lesson school java socket
---

Дедлайн:
--------

 - 9-1: -
 - 10-1: 9 февраля
 - 11-1: 9 февраля

Данное задание является вводным (и завершающим ```:-)```) в сетевое взаимодействие. Когда вы просматриваете сайт, играете в мультиплеерную игру, используете мессенджер и т.п. - происходит взаимодействие вашего устройства с другими устройствами посредством интернета.
Т.е. программа которую вы используете отправляет очень много сообщений (различного содержания: это может быть текст вашего сообщения или координаты вашего персонажа в игровом мире).
Так же используемая программа получает много сообщений от других устройств: в случае чата - это входящие сообщения, в случае игры - координаты остальных игроков.

Мы напишем две простые программы: сервер и клиент.

```Задача клиента:``` подключиться к серверу и отправлять ему сообщения которые вводит пользователь, получать на них ответ и отображать текст пользователю.
 
```Задача сервера на 4:``` ожидать подключения клиента и отвечать на все входящие сообщения тем же текстом, который прислал клиент.

За реализацию таких двух программ в 10-1 и 11-1 можно получить максимум 4. Чтобы получить 5 сервер должен уметь больше:

```Задача сервера на 5:``` ожидать подключения многих клиентов и при получении входящего сообщения - высылать полученный текст всем подключенным клиентам (т.е. например клиент 1 отправил текст "A", клиент 2 отправил текст "Б", тогда сервер каждое из этих сообщений отправит этим двум клиентам, и каждый клиент увидит как свое сообщение, так и сообщения остальных клиентов).

0) Сетевое взаимодействие
-------------------------

Представьте что у каждого компьютера есть несколько тысяч виртуальных разъемов. Это так называемые ```порты``` - они обладают значениями ```от 0 до 65536``` (рекомендую для использования любой из пространства ```1024—49151```, например ```2391```). 
Они позволяют установить соединение между двумя компьютерами (т.е. сообщения будут идти между одним из портов первого компьютера через интернет к порту второго компьютера).

Чтобы в интернете или локальной сети можно было обращаться к другим компьютерам - у каждого есть свой адрес, так называемый ```ip```-адрес. Это уникальный идентификатор имеющий вид ```a.b.c.d```, где каждая буква - число от 0 до 255 (например: ```5.18.192.135```).
 
Если есть компьютер А с ip-адресом ipA и есть компьютер Б с ip-адресом ipB, то чтобы А смог общаться с Б - им нужно установить связь. Для этого компьютер А стучиться (пытается установить соединение) по адресу ipB в конкретный порт, например в нашем случае пусть это будет порт ```2391```.
 
Чтобы соединение успешно установилось - необходимо чтобы на компьютере Б была запущена программа-сервер, которая ожидает подключающихся клиентов по порту 2391.

Итого если на компьютере Б с адресом ipB запущена программа, которая ожидает подключение клиентов по порту 2391, и есть компьютер А, на котором запустилась программа, которая пытается установить соединение с компьютером по адресу ipB и порту 2391 - то будет установлено двустороннее соединение, по которому можно обмениваться информацией.

1) Простой сервер
-----------------

Итак нам нужно написать программу которая ожидает подключения клиентов по порту 2391 и когда клиент подключается - начинает ему отвечать зеркальными сообщениями (т.е. вести себя как эхо).

В Java есть специальный класс ```Socket```, который представляет "разъем"/"сокет" соединения, т.е. один из концов канала обмена сообщениями.
Нам нужно создать сокет, который пока что ни с кем не соединен, но очень хочет - т.е. находится в состоянии ожидания подключений, для этого есть более конкретный класс ```ServerSocket```.
   
Создаем его в main-функции:

```java
ServerSocket socket = new ServerSocket(port);
```

Обратите внимание на параметр конструктора - нужно указать порт, на котором сокет ожидает подключающихся клиентов.

Теперь надо перейти в режим ожидания:

```java
Socket client = null;
socket.accept();
```

Эта функция блокируется до первого подключения клиента по этому порту.
Когда клиент подключится и соответственно соединение будет установлено - эта функция вернет сокет (т.е. объект класса ```Socket```)
 который уже является сокетом установленного соединия со стороны сервера, поэтому результат исполнения функции ```accept``` надо сохранить в переменную типа ```Socket``` - например логично назвать такую переменную ```client```, т.к. это соект соединения с клиентом.

У ```Socket``` уже можно получить входной и выходной поток (через методы ```getInputStream``` и ```getOutputStream```) - они обладают тем же типом, что и ```System.in``` и ```System.out```. Поэтому о том, как считывать из входного потока (который возвращает ```getInputStream``` - т.е. это поток данных которые идут от клиента к серверу)
 и как писать в выходной поток (т.е. в результат ```getOutputStream``` - т.е. в поток данных от сервера к клиенту) можно прочитать [тут](/lessons/239/school/java/olymp/2017/01/10/olymp-stub.html) (единственная разница - вторым аргументом в конструктор ```PrintWriter``` нужно передать ```true``` - это включит автоматическую отправку буфера на каждое сообщение).

Когда клиент закроет канал - метод ```readLine()``` класса ```BufferedReader``` вернет ```null``` - и тогда сервер должен будет вернуться обратно на стадию ожидания нового клиента - т.е. опять вызвать метод ```accept()```.

Но как и при работе с файлами - сокет соединения с клиентом надо закрывать, т.е. после того как ```readLine()``` вернул ```null``` - требуется вызвать метод ```close()``` у объекта класса ```Socket```, который представляет соединение с клиентом (т.е. то, что вернул метод ```accept()```).

2) Простой клиент
-----------------

Итак нам нужно написать программу которая подключается по порту 2391 к компьютеру с каким-то ip-адресом и шлет ему сообщения + получает на них ответы.

Мы и сервер, и клиент будем запускать на одном и том же компьютере, и для подобного случая есть зарезервированный специальный ip адрес - ```127.0.0.1``` (так же известный как ```localhost```), поэтому можно считать что сервер всегда существует по такому адресу.

В Java есть специальный класс ```Socket```, который представляет "разъем"/"сокет" соединения, т.е. один из концов канала обмена сообщениями.
 Для того чтобы инициировать соединение с сервером - надо создать сокет с адресом сервера к которому мы стучимся (```127.0.0.1```) и портом на котором нас ожидает сервер (```2391```).
   
Создаем такой сокет в main-функции:

```java
String host = "127.0.0.1";
int port = 2391;
ServerSocket socket = new Socket(host, port);
```

Как и у сервера код работающий с потоками такой же как и при работе с консольным вводом-выводом. Методы получения потоков у ```Socket``` такие же как и у ```ServerSocket```, который обсуждался выше.

Т.е. теперь достаточно в цикле слать сообщения серверу через выходной поток получаемый через метод ```getOutputStream``` и печатать в консоль получаемые через ```getInputStream```-поток ответные сообщения.

P.S. не забудьте вызвать метод ```close()``` у сокета соединения.

3) Сервер чата
--------------

Теперь мы хотим чтобы сервер пересылал все входящие сообщения всем подключенным клиентам.

Бла-бла-бла, бла-бла-бла. Для этого нужно создавать по потоку на клиент. Бла-бла-бла, бла-бла-бла.

Допишу позже.

4) Тестирование и отправка задания
----------------------------------

Чтобы протестировать - вам надо сначала запустить сервер, а затем клиент. Переключаться между их консолями можно нажимая мышкой на вкладки в нижней части IDE.

Отправляйте выполненное задание ввиде zip-архива ```src``` папки, и пожалуйста:

 - Тему письма называйте правильно (номер этого задания, как написано в самом верху - 40, пример: ```Задание 40 16-1 Полярный Коля```)
 - zip-архив (или 7zip) называйте по тем же правилам, как назывались патчи (только расширение файла теперь не ```.patch```, а ```.zip```, пример: )
 
Т.е. формат такой же как и про [патч](/lessons/239/lesson/school/1703/05/16/Patch.html), только вместо ```.patch``` вы шлете ```.zip```.

5) Частые проблемы
------------------

```Ситуация:``` При запуске сервера выводится ошибка ```java.net.BindException: Address already in use (Bind failed)```

Это означает что слушать по такому порту сервер не смог, т.к. этот порт уже кем-то занят. Скорее-всего вы забыли остановить запущенный ранее сервер (нажать красную квадратную стоп-кнопку).
